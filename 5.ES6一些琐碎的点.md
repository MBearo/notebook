# ES6一些琐碎的点

## 作用域

1. var的提升机制

    ```javascript
    function getValue(condition){
      if(condition){
        var varlue="blue"
        return value
      }else{
        // 这里也可以访问value，但是值为 undefined
        return null
      }
    }
    ```

2. typeof相对安全，但是在临时性死区里也会抛错

    ```javascript
    if(condition){
      console.log(typeof value)
      let value="blue"
    }
    ```

3. let const 不能覆盖全局变量，但是可以屏蔽它

## 函数

1. ES6之前函数内默认值比较安全的方法

    ```javascript
    function a(time){
      time = (typeof time !== 'undefined' ) ? time:2000
    }
    ```

2. 函数内的arguments

    ```javascript
    function mix(first,second){
      console.log(first===arguments[0])
      console.log(second===arguments[1])
      first='c'
      second='d'
      console.log(first===arguments[0])
      console.log(second===arguments[1])
    }
    mix('a','b')
    ```

    1. ES5 非严格模式 true true true true
    2. ES5 严格模式   true true false false
    3. ES6 没有默认值 true true true true
    4. ES6 有默认值 true true false false

3. 默认参数可以为前一个参数,但是前一个默认参数不能为后一个

    ```javascript
    function mix(first,second=first){}
    ```

4. 默认参数单独作用域，不能访问函数体内声明的变量
5. 函数的length不计算 ...arg

    ```javascript
    function mix(first,second){} //mix.length 2
    function mix(first,second,...arg){} //mix.length 2
    ```

# 你不知道js2

## 第一章：什么是作用域？

当你写完你的前几个程序时，你可能已经对创建变量和在其中存储数值有了一定的了解。与变量打交道是我们在编程中做的最基础的事情之一！

但你可能没有仔细考虑过引擎用来组织和管理这些变量的基本机制。我指的不是计算机上的内存如何分配，而是：JS如何知道哪些变量可以被任何给定的语句访问，以及它如何处理两个同名的变量？

诸如此类问题的答案以定义明确的规则的形式出现，称为作用域。本书将对作用域的所有方面进行挖掘--它是如何工作的，它有什么用处，要避免的问题，然后指出指导程序结构的常见作用域模式。

我们的第一步是揭示JS引擎在程序运行**前**是如何处理的。

## 关于这本书

欢迎来到《你不知道的JavaScript》系列的第二版！如果你已经完成了《开始》（第一册），那么你就来对了。如果没有，在你继续阅读之前，我建议你从这里开始，为自己打好基础。

我们的重点将是JS语言的三大支柱中的第一个：作用域系统和函数闭包，~~以及模块设计模式的强大功能~~。

JS通常被归类为解释性脚本语言，所以大多数人认为JS程序是单一的、自上而下执行的。但实际上，JS在**开始执行之前**是在一个单独的阶段进行解析/编译的。在最初的解析/编译阶段，代码作者将根据作用域规则对变量、函数和块的位置进行分析。由此产生的作用域结构一般不受运行时条件的影响。

JS的函数是一等公民；它们可以像数字或字符串一样被赋值和传递。但由于这些函数保存并访问变量，所以无论函数最终在程序中的哪个位置被执行，它们都会保持原有的作用域。这就是闭包。

模块是一种代码组织模式，其特征是公共方法具有访问(通过闭包)模块内的隐藏变量和函数的特权。

## 编译和解释

你以前可能听说过编译，但它可能看起来像一个神秘的黑盒子，源代码从一端输入，可执行程序从另一端输出。

但它并不神秘或神奇。编译是一系列处理代码文本并将其转换为计算机可以理解的指令列表的步骤。通常，整个源代码是一次性转换的，这些生成的指令被保存为输出(一般在一个文件中)，可以稍后执行。

你可能也听说过代码可以被解释，那么与编译有什么不同呢?

解释类似于编译的任务，因为它把你的程序转换成计算机可以理解的指令。但是处理方式不同。与一次编译的程序不同，在解释过程中，源代码是逐行转化的;~~在立即处理源代码的下一行之前，执行每一行或每一条语句。~~

图1：编译代码与解释代码

图1说明了程序的编译与解释。

这两种处理模式是互斥的么？一般来说，是的。然而，这个问题很微妙，因为解释实际上可以采取其他形式，而不仅仅是逐行操作源代码。现代JS引擎实际上在处理JS程序时使用了大量的编译和解释变体。

记得我们在《入门》一书的第1章中提到了这个话题。我们的结论是，JS被描绘成一种编译语言是最准确的。为了方便读者，下面的部分将重新讨论并扩展这个结论。

## 编译代码

但首先，为什么JS是否编译很重要?

作用域主要是在编译过程中确定的，因此理解编译和执行之间的关系是掌握作用域的关键。

在传统的编译器理论中，一个程序由编译器在三个基本阶段中处理:

1. 分词/词法分析:这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被成为词法单元（token）。例如，考虑程序`var a = 2;`。这段程序通常会被分解成为下面这些词法单元：`var`、`a`、`=`、`2`和`;`。空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。

   (分词（Tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过*有状态*还是*无状态*的方式进行的。简单来说，如果词法单元生成器在判断`a`是一个独立的词法单元还是其他词法单元的一部分是，调用的是有状态的解析规则，那么这个过程被称为**词法分析**。)

2. 解析:获取标记流(数组)并将其转换为嵌套元素树，这些元素共同表示程序的语法结构。这叫做抽象语法树(AST)。

   例如，树的`var a = 2;`可能从一个名为 `VariableDeclaration` 的顶级节点开始，还有一个子节点名为`Identifier`(其值为`a`)，另一个子节点名为`AssignmentExpression`(其本身有一个子节点`NumericLiteral`(其值为`2`))。

3. 代码生成:获取 AST 并将其转换为可执行代码。这部分内容因语言、目标平台和其他因素的不同而有很大差异。

   JS引擎接受刚才描述的 AST`var a = 2;`并将其转换为一组机器指令，用于实际创建一个名为a的变量(包括预留内存等)，然后将值存储到到`a`。

> JS引擎的实现细节(利用系统内存资源等)比我们在这里挖掘的要深入得多。我们将把重点放在程序的可观察行为上，让JS引擎管理那些更深层次的系统级抽象。


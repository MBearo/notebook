# 头条校招机试题

C++ STL 里的 vector 主要使用翻倍拷贝来实现可变长数组的功能。举个例子，若已有 vector 容量8，且目前已经装满，则在运行 push_back 时，会新建一个长度为16（原长度*2）的数组空间，将原有的数据全部复制到新数组中，再在这个数组中执行push_back。现在请问，对于一个初始长度为1的vector，不断地执行push_back方法，其每次执行的均摊时间复杂度为多少？

* O(logn)
* O(loglogn)
* O(n)
* O(1)

对数组[44,91,93,30,21,9,89]进行大顶堆排序后，再删除最大值后，数组的排序顺序是

* [89,44,91,30,21,9]
* [91,44,89,30,21,9]
* [9,30,21,44,89,91]
* [9,21,30,44,89,91]

箱子里有20个红球，18个白球，我们注意从箱子里随机拿球出来。真个拿球的过程中，箱外白球数至少有一次和箱外红球数相等的概率是？

* 8/9
* 18/19
* 19/20
* 9/10

f(x)=x-2*sin(x)共有几个零点？

* 5
* 3
* 无穷
* 1

x=x+1
y=x+y
假设在单核无超线程cpu场景下执行上面的代码，有三个线程分别执行这段代码，在所有线程开始之前，假设有两个变量x和y，x和y都被初始化为1，x和y的值会且只会被这三个线程修改。线程有可能随时被抢占，假设执行x=x+1或y=x+y是原子的。请问以下哪些是线程全部执行完之后可能得到的结果

* x=4,y=10
* x=4,y=13
* x=3,y=11
* x=4,y=14

很多糖果，6个孩子自己分。第一个孩子把糖分成相等的6堆，多出1个。于是他自己吃了1个，然后拿走一堆。第二个小孩一看，只有5堆糖，于是把5堆合在一起，分成相等的6对，又多出来1个。于是他也吃掉1个，拿走1堆。其他小孩也是这么分的。请问这些糖果至少有几个？

数组里找出现次数最多的字符串。数组内数据是乱序。

第一行包含两个整数n和m。
随后n行，每行有两部分组成，第一部分是机房编号，第二部分是网段信息，格式如下：
idc net
随后m行，每行是一个ip，表示需要查询的ip
保证所有的网段以及ip都为ipv4格式，不存在ipv6的输入数据
要注意，输入有可能存在一个大网段被分成多个小网段切分完毕的情况
数据范围：
对于30%的数据：1<=n<=10,1<=m<=100
对于60%的数据：1<=n<=1000,1<=m<=5000
对于100%的数据：1<=n<=5000,1<=m<=5000
输出描述：
输出一共有m行，每行为一个整数，代表第Mi行ip对应的机房编号。
如果所输入的ip没有找到对应的网段信息，就输出-1
输入：
4 4
1 10.1.2.0/24
2 10.1.0.0/16
1 10.1.5.0/24
2 10.1.2.128/25
10.1.2.3
10.1.2.129
10.3.2.1
10.1.5.2
输出：
1
2
-1
1


甲乙两个人玩抽牌，一共n张牌，两人轮流抽，先手者的第一次抽可以抽任意张但不可抽完，以后每次抽都只能抽取不超过上一次抽排数的两倍（不可不抽）。谁先抽完牌谁赢（没得抽的算输）。由甲先抽。假设该游戏进行t轮，每轮重新给出新的n。请问先手的甲一共能赢其中的多少轮？
输入描述：
第一行，一个数字t
接下来t行，每行一个数字，n
？？不知道是啥
输出：
一个数字x，代表甲赢的轮数
输入：
2
4
5
输出：
1

我们在使用Tensorflow等编写的神经网络时，为了使代码逻辑清晰，可能会造成运行时的低效。
(p0-(p1/(p0+(p3-p4))))+(p2*(p1/(p0+(p3-p4))))
在Tensorflow中可以表示为如下图一，其中p1/(p0+(p3-p4))计算了两次。还好Tensorflow提供的XLA（Accelerated Linear Algebra）对此进行了优化，只需计算一次，计算流程被优化为如下图二形式。
![tran](/assets/37/tran.png)
思考这个过程是怎么完成的。他已经把这个问题简化，使用前缀表示法来表示这些计算式，并限定操作符于{+,-,*,/}操作数为单个小写字母。可描述如下：
E in {a,b,...,z}
f in {+,-,*,/}
F = f(E,E)
F = f(E,F)
令上述表达式中p0=a,p1=b,p2=c,p3=d,p4=e,前缀法可表示为：
+(-(a,/(b,+(a,-(d,e)))),*(c,/(b,+(a,-(d,e))))
他希望能将这个表达式的计算节点优化的最少。
对于每个表达式，将其计算节点优化到最少。并将有花的子表达式以一个数字表示，把这个数字指向等于此子表达式的根节点的序号。节点的序号从1开始，按前序遍历分配，如果是重复节点则不分配编号。如“a+a”可以转换为前缀表达式“+(a,a)”，第二个“a”发现第一个“a”作为节点（编号2）已经出现过，因此可优化为“+(a,2)”，2表示指向编号为2的节点。而在“+(-a,/(b,+(a,-(d,e)))),*(c,/(b,+(a,-(d,e))))”中，“a”和“/(b,+(a,-(d,e)))”都是重复的，其中a第一次出现的节点编号为3，“/(b,+(a,-(d,e)))”第一次出现的根节点“/”编号为4，因此可以有华为“+(-(a,/(b,+(3,-(d,f)))),*(c,4))”。具体如下图所示。
![tran2](/assets/37/tran2.jpg)
输入描述：
第一行包含一个数字c，表示将要处理的表达式行数，不超过200行。接下来的c行每行包含一个表达式，表达式的形式由上述给出（已转换为前缀形式，无空格，有括号）。最多包含10000各节点。
输出描述：
对于每个表达式，输出按说明中优化后的表达式。如“+(-(a,/(b,+(a,-(d,f)))),*(c,/(b,+(a,-(d,f)))))”将优化得到“+(-(a,/(b,+(3,-(d,f)))),*(c,4))”
输入：
5
+(a,b)
+(a,a)
+(+(*(b,c),g),*(*(b,c),e))
+(-(a,/(b,+(a,-(d,f)))),*(c,/(b,+(a,-(d,f)))))
+(-(a,-(b,c)),+(-(b,c),+(e,+(e,f))))
输出：
+(a,b)
+(a,2)
+(+(*(b,c),g),*(3,e))
+(-(a,/(b,+(3,-(d,f)))),*(c,4))
+(-(a,-(b,c)),+(4,+(e,+(9,f))))

有一台机器，可批量输入单词，会返回其翻译，但不知道对应关系。
现有1000个单词，最少需要几次就能确定他们的翻译

多个机房，每个机房有可能有多个网段（如10.1.2.0/24），网段之间会有包含关系，当出现包含关系时，以小的网段为准。
如机房1对应的网段10.1.0.0/16，机房2对应网段10.1.2.0/24，那么现在有一个ip 10.1.2.3，其应当归属于机房2.
公司内我们经常会遇到一个场景：要查询一个ip所在的机房。
请你写一个程序，根据输入的网段信息和所需插叙你的ip给出所在的机房。为了讲话问题，在这里我们认为所有的ip都是可分配的，即不考虑网段地址和广播地址，将这两种地址也认为是可分配地址。

求a+b的和
输入描述：
多组输入，每一行有两个数A，B。0 < A，B < 1000000
输出描述：
每行输出一个结果

以下那些陪徐算法的平均时间复杂度是O(nlogn)

* 插入排序
* 冒泡排序
* 归并排序
* 堆排序
* 快速排序
